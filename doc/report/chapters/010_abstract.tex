\chapter*{}
\begin{abstract}
% \linespread{2}\selectfont

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Motivation:
In the world of self-driving cars and virtual reality games it is becoming
increasingly important to represent digitally what we see.
Therefore, using high resolution
cameras, images of the environment have been recorded.
These large images are processed to be presented three dimensionally. 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Problem statement:
This image processing task needs to be accelerated to have a fast work flow. 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Approach:
A dedicated hardware approach using Field Programmable Gate Arrays (FPGA) was
implemented that is scalable onto multiple FPGAs.
% How
% Using HLS: Wallis and controller
% Using VHDL: Wallis and controller
% 
In a first run High level synthesis was used to describe a Wallis local contrast enhancment filter in C language that was then synthesized to hardware description language. To further improve throughput a VHDL solution was implemented. A memory management unit was introduced to cache necessary image data to reduce Ethernet bandwidth usage.
% High level synthesis was used to describe a Sobel filter operation in
% C language that was then synthesized to hardware description language.
% Simulations were used to ensure correct operation. 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Results:
The result is an image
processing core and a file transfer protocol stack on top of the User Datagram
Protocol (UDP) to transfer the images from a computer to the FPGA over gigabit Ethernet. 
The Wallis filter core processes data at a rate of one
pixel per clock at 125MHz which corresponds to 125 megapixels per second. 
Studies on scalability show how the processing load can be distributed onto multiple FPGA on a local area network and benchmarks present the performance against CPU based image processing.
% The
% code runs on an Xilinx Artix 7 evaluation board and can simply be extended due to a clean source code structure. 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Conclusions:
With some additions, workload distribution is possible. This study proves 
that a dedicated hardware approach for image processing is possible and will
speed up the process of creating virtual representations of reality.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\vspace{3em}
\begin{tabular}{l p{.95\textwidth}}
    \textbf{Team members}  & Noah H\"utter, Jan Stocker \\
    \textbf{Keywords}      & FPGA, UDP, Image Processing, Wallis Filter \\
\end{tabular}

\end{abstract}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Motivation:
% Why do we care about the problem and the results? If the problem isn't obviously "interesting" it might be better to put motivation first; but if your work is incremental progress on a problem that is widely recognized as important, then it is probably better to put the problem statement first to indicate which piece of the larger problem you are breaking off to work on. This section should include the importance of your work, the difficulty of the area, and the impact it might have if successful.
% 
% Why do we care about the problem? 
% What practical, scientific, theoretical or artistic gap is your research filling?
% 
% 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Problem statement:
% What problem are you trying to solve? What is the scope of your work (a generalized approach, or for a specific situation)? Be careful not to use too much jargon. In some cases it is appropriate to put the problem statement before the motivation, but usually this only works if most readers already understand why the problem is important.
% 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Approach:
% How did you go about solving or making progress on the problem? Did you use simulation, analytic models, prototype construction, or analysis of field data for an actual product? What was the extent of your work (did you look at one application program or a hundred programs in twenty different programming languages?) What important variables did you control, ignore, or measure?

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Results:
% What's the answer? Specifically, most good computer architecture papers conclude that something is so many percent faster, cheaper, smaller, or otherwise better than something else. Put the result there, in numbers. Avoid vague, hand-waving results such as "very", "small", or "significant." If you must be vague, you are only given license to do so when you can talk about orders-of-magnitude improvement. There is a tension here in that you should not provide numbers that can be easily misinterpreted, but on the other hand you don't have room for all the caveats.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Conclusions:
% What are the implications of your answer? Is it going to change the world (unlikely), be a significant "win", be a nice hack, or simply serve as a road sign indicating that this path is a waste of time (all of the previous results are useful). Are your results general, potentially generalizable, or specific to a particular case?
% 
% https://users.ece.cmu.edu/~koopman/essays/abstract.html