% ==============================================================================
%
%                             Verification & Benchmark
%
% ==============================================================================
\chapter{Verification \& Benchmark} \label{chapt:ver_bench}
With the image processing an dataflow parts implemented, they can be verified
and benchmarked. The next chapters hold the verification process of both the
image processing part and the dataflow part. After both components are verified
they are benchmarked as one unity against a computer based implementation in
chapter \ref{ch:benchmark}.


% ==============================================================================
%
%                             Verification
%
% ==============================================================================
\section{Verification} \label{ch:verification}
The verification process ensures that all components work as expected. It is
split into the image processing and dataflow parts. They were tested
independantly to reduce complexity and simulation time. The system as a unity is
then tested in chapter \ref{ch:benchmark} benchmark.

% ==============================================================================
%
%                             Image Processing
%
% ==============================================================================
\subsection{Image Procession}\label{ch:verification:imageprocessing}
The verification of the image processing is validated with two different 
methods. Firstly, an image is processed with the Wallis filter and compared 
with a reference image. The reference image is generated from a C/C++ program 
which calculates using floating point calculations. In the second aspect the 
throughput is validated. \\
The devices under validation (DUV) are two written in Vivado HLS using C/C++ 
and one VHDL version. The Vivado HLS versions differ in the input stream. One 
has an 8 bit AXI4-Stream and the other one has a 256 bit AXI4-Stream input. The
VHDL is an 8 bit AXI4-Stream.

\subsubsection*{Image Comparsion}
During the verification an image is processed with the Wallis filter. The Wallis filter is run on the computer as a C/C++ program and has floating point variables. This Wallis filtering is used as a reference image. Two images (room and mountain), added in the appendix \ref{app:images_wallis}, are available as reference images. \\
The reference images are passed through the DUV and compared with the reference images. The root-mean-square error (RMSE) serves as a rule. The RMSE indicates how well the  Wallis filtered image deviates on average from the reference image \cite{rmse}. The parameters for the Wallis filter, which were used for the images, can be found in table \ref{tab:parameter}.

\begin{table}[tb!]
    \centering
    \begin{tabular}{l l l l l}
        \toprule
        Image & Brightness & Contrast & Global Mean & Global Variance \\
        \midrule
        room \ref{fig:ref_room} & 0.5 & 0.8125 & 127 & 3600 \\
        mountain \ref{fig:ref_mountain} & 0.5 & 0.8125 & 127 & 3600 \\
        \bottomrule
    \end{tabular}
    \caption{Parameters for the Wallis filter}
    \label{tab:parameter}
\end{table}



Table \ref{tab:rmse_room} lists the RMSE values of the room image and the RMSE values of the mountain image in the table \ref{tab:rmse_mountain}. They represent the deviation from the reference image in percent. The deviation from the C/C++ program with the 8 bit AXI4 stream and the 256 bit AXI4 stream does not differ from each other. A total deviation of 0.32\% has been measured in the room image. This corresponds to an intensity value of 0.816 in the range of 0 - 255. There is also only a deviation of 0.33\% in the mountain image. The GHDL verification is with 1.23\% respectively ??? already much higher. The intensity deviates by 3.14 pixels. This is due to the fact that in the VHDL code the mean value and the variance are not exactly calculated in contrast to the HLS versions. \todo{Begruednung!!!}

\begin{table}[tb!]
    \centering
    \begin{tabular}{l l l l}
        \toprule
        DUV & C/C++ Simulation (HLS) & RTL Simulation (HLS) & GHDL \\
        \midrule
        C/C++ 8 bit (HLS) & 0.32\% & 0.32\% & -\\
        C/C++ 256 bit (HLS) & 0.32\% & 0.32\% & - \\
        VHDL 8 bit & - & - & 1.23\% \\
        \bottomrule
    \end{tabular}
    \caption{RMSE of the Wallis filter verification of the room image}
    \label{tab:rmse_room}
\end{table}

\begin{table}[tb!]
    \centering
    \begin{tabular}{l l l l}
        \toprule
        DUV & C/C++ Simulation (HLS) & RTL Simulation (HLS) & GHDL \\
        \midrule
        C/C++ 8 bit (HLS) & 0.33\% & 0.33\% & - \\
        C/C++ 256 bit (HLS) & 0.33\% & 0.33\% & - \\
        VHDL 8 bit & - & - & 0.49\% \\
        \bottomrule
    \end{tabular}
    \caption{RMSE of the Wallis filter verification of the mountain image}
    \label{tab:rmse_mountain}
\end{table}



\subsubsection*{Throughput}
During verification, the throughput of the Wallis filter will also be evaluated. For this purpose, the throughput at the input of the filter is displayed. This means how many pixels per clock are loaded into the Wallis filter. Again, the three different methods (HLS 8 bit, HLS 256 bit \& VHDL 8 bit) of the Wallis filter are compared. The table \ref{tab:throughput} lists the three different methods. The 8 bit versions should have a throughput of one pixel per clock, this is 125Mp/s. But the HLS 8 bit version only reached 21 pixels in 86 clocks. This results in a throughput of 30.5Mp/s. This is 4 time slower than the theoretical value. This has to do with the fact that the division requires 23 clocks and that the loop cannot be pipelined by reading the pixels (see chapter \ref{ch:hls:div} and \ref{ch:ip:axi}). For this reason the 256 bit version was developed. This has a theoretical maximum of 2625Mp/s. A throughput of 21 pixels could be achieved in 11 clock cycles. This is equivalent to 238.6Mp/s. in relation to the 8 bit version only a better throughput of a factor of 7.8 could be achieved. The limiting factor is still the division. With the VHDL version the theoretical maximum of 125Mp/s has been reached.

\begin{table}[tb!]
    \centering
    \begin{tabular}{l l l l}
        \toprule
        DUV & Target [pxl/clk] & Actual [pxl/clk]  & Throughput [Mp/s]\\
        \midrule
        C/C++ 8 bit (HLS) & 1 & 21/86 & 30.5\\
        C/C++ 256 bit (HLS) & 21 & 21/11 & 238.6 \\
        VHDL 8 bit & 1 & 1 & 125 \\
        \bottomrule
    \end{tabular}
    \caption{Throughput of the Wallis filter related to the input pixels}
    \label{tab:throughput}
\end{table}


% ==============================================================================
%
%                             Dataflow
%
% ==============================================================================
\subsection{Dataflow}\label{ch:verification:dataflow}
The dataflow part is again divided into two parts, the communication and
controller parts. While in the communication part only the most recent version
is tested (reffering to chapter \ref{chapt:dataflow} explaining the solotion
A and B with streaming interface), both versions of the controller are verified.

\subsubsection*{Communication}
The communication part was in a large part taken from the last semester project
and was been thoroughly tested and validated in the project report 
\cite{p5report}. The three new implemented features are verified in this
chapter. They consist of:
\begin{itemize}
    \item Acknowledge
    \item User registers
    \item Stream interface
\end{itemize}

\vspace{1ex}
\textbf{Acknowledge:} To test the acknowledge function, a file was sent to the
FPGA from the computer
and the Ethernet traffic monitored with Wireshark Netowrk Protocol Analyzer.
Wiresharks packet dissections are exported to a json file that was then analyzed
using the \texttt{uftcheck} utility. It was written to analyze network pacekts
for UFT transfers. The first lines of output yielded:

    \begin{adjustbox}{max width=1.7\textwidth}
\begin{minipage}{2\linewidth}
    \begin{lstlisting}[
        % basicstyle=\small, %or \small or \footnotesize etc.
        % columns=fullflexible,
        % frame=single,
        % breaklines=false,
        % style=CStyle, 
        % caption=ack buffer allocation, 
        % label=lst:ackbufalloc
        ]
+------+----------------------+----------------------+-----+------------+------+------+
| Pack |         From         |          To          | D/C |  Control   | TCID | SEQ  | 
+------+----------------------+----------------------+-----+------------+------+------+
|  1   | 192.168.5.10 (50719) | 192.168.5.9 (42042)  |  C  |  FT Start  |  12  | 1036 |
|  2   | 192.168.5.10 (50719) | 192.168.5.9 (42042)  |  D  |            |  12  |  0   |
|  3   | 192.168.5.9 (42042)  | 192.168.5.10 (50719) |  C  | ACK packet |  12  |  0   |
|  5   | 192.168.5.10 (50719) | 192.168.5.9 (42042)  |  D  |            |  12  |  1   |
|  6   | 192.168.5.9 (42042)  | 192.168.5.10 (50719) |  C  | ACK packet |  12  |  1   |\end{lstlisting}
\end{minipage}
\end{adjustbox}

The sending PC starts a file transmission with a file transfer start packet and
the first data packet. The next packet (3) is comming from the FPGA to the PC
and acknowledges the first data packet (sequence 0). To verify that all packets
are acknowledged, the sending program reports an acknowledge status after the
files has been sent. 

\begin{minipage}{\linewidth}
    \begin{lstlisting}[
        % basicstyle=\small, %or \small or \footnotesize etc.
        % columns=fullflexible,
        % frame=single,
        % breaklines=false,
        % style=CStyle, 
        % caption=ack buffer allocation, 
        % label=lst:ackbufalloc
        ]
$ ./sender 192.168.5.9 42042 payload/cat.jpg
UFT Sender demo
destination 192.168.5.9:42042
HURRAY! All 1036 packets have been acknowledged.
time elapsed: 1.18s Speed: 0.859 MB/s Size: 1.012 MB\end{lstlisting}
\end{minipage}

\vspace{1ex}
\textbf{User register:} To test wether the user registers can be written and are
output correctly by the communication core, a integrated logic analyzer (ILA)
was used. An ILA can be configured on the FPGA to record internal signals. The
results are transferred to the PC over USB and displayed in \gls{vivadohlx}. 


\subsubsection*{Controller}

% ==============================================================================
%
%                             Benchmark
%
% ==============================================================================
\section{Benchmark}\label{ch:benchmark}

