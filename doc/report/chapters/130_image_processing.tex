% ==============================================================================
%
%                             Image Processing
%
% ==============================================================================
\chapter{Image Processing}  \label{chapt:image_processing}
The Wallis filter is implemented as an image processing algorithm. First follows the concept of the algorithm and following the implementation of the filter in the Vivado HLS using C/C++ code. The simplifications and optimizations of the algorithm with Vivado HLS are also explained in this chapter. \\
During the work on the project it was discovered that the initial approach to the problem would not lead to the optimum solution (see chapter \ref{chapt:ver_bench}. This is why a second implementation of the Wallis fitler was made using VHDL. This second implementation is explained in the chapter \ref{ch:ip:imp_vhdl} with a concept of the VHDL design.

\section{Concept} \label{ch:ip:concept}
Figure \ref{fig:concept} shows the concept of the C/C++ code programmed in the Vivado HLS. First, the local mean and the variance must be calculated so that the Wallis filter can be applied afterwards with the parameters and the pixel $I(x,y)$ that is to be calculated. The calculation of mean and variance is explained in chapter \ref{ch:ip:mean_var}. The calculated pixel is $I'(x,y)$. \\
The sequence of the code is shown in figure \ref{fig:sequence}. This consists of an initialization and a iteration. During the initialization, the complete neighborhood (here as an example 3x3) is read and the central pixel of the neighborhood is calculated. To calculate the next pixel, only one new column (gray marked) is read and the old column (hatched line) can be forgotten. This step is the so called iteration.\\
The code is row based. This means that each new row of an image has the initialization procedure.

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        \input{images/image_processing/concept.tikz}
    \end{adjustbox}
    \caption{Concept of the Wallis filter implementation}
    \label{fig:concept}
\end{figure}

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        \input{images/image_processing/init_iter.tikz}
    \end{adjustbox}
    \caption{Sequence of the code with initialization and iteration}
    \label{fig:sequence}
\end{figure}

\subsubsection*{Abbreviations}
This table lists constants which were used in the code and which recur in the documentation.

\begin{table}[tb!]
    \centering
    \begin{tabular}{l l l}
        \toprule
        Name & Value & Description  \\
        \midrule
        WIN\_SIZE & 441 & Chosen as neighobrhood (N)
        \\
        WIN\_LENGTH & 21 & $\sqrt{WIN\_SIZE}$ 
        \\
        \bottomrule
    \end{tabular}
    \caption{Constants from the Code}
    \label{tab:c_div}
\end{table}


\section{Implementation HLS \& Optimization}
The following three chapters explain the implementation of the Wallis filter in C/C++ code. First, the simplification of the mean and the variance. Then the Fixed Point calculation of the Wallis equation and in the third chapter the optimizations using pragmas in Viviado HLS.

\subsection{Mean \& Variance} \label{ch:ip:mean_var}
In this section we will go in detail on the mean and the variance, so that it can be calculated more efficiently with the FPGA. The problem is that the equation we know for the variance (\ref{eq:var1}) must first calculate the mean (\ref{eq:mean}). \\
No adjustment is necessary for the equation for the mean. This can be used as usual. The following equation	is used to calculate the mean:
\begin{equation}
    \mu = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}
    \label{eq:mean}
\end{equation} 

The equation we know for variance \ref{eq:var1} is adjusted for the calculation.
As can be seen, the mean must first be calculated so that the calculation of the
variance can be started at all. The goal is to start the calculation of the mean
and the variance at the same time. So that this can be implemented more
efficiently in the FPGA.
Equation \ref{eq:var1} is expanded and is given the equation \ref{eq:var2}. If
this is still represented a little differently one gets the equation 
\ref{eq:var3}. In this case it is to be recognized that in the second term the
mean results $\mu = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}$. In the third term,
the sum $\sum_{i = 0}^{N - 1} 1$ equals to $N$.
This adjustment leads to equation \ref{eq:var} implemented in the FPGA. The implementation of the equation is shown in the concept in figure \ref{fig:concept} in the mean and variance block.
\begin{align}
    \sigma^{2} & = \frac{1}{N} \sum_{i = 0}^{N - 1} (x_{i} - u)^{2} \label{eq:var1}\\ 
    		& = \frac{1}{N} \sum_{i = 0}^{N - 1} (x_{i}^{2} - 2 \mu x_{i} + \mu^{2})  \label{eq:var2}\\
    		& = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}^{2} - 2\mu \frac{\sum_{i = 0}^{N - 1} x_{i}}{N} + \frac{1}{N} \mu^{2} \sum_{i = 0}^{N - 1} 1 \label{eq:var3}\\
    		& = \frac{\sum_{i = 0}^{N - 1} x_{i}^{2}}{N}  - 2\mu^{2} + \mu^{2} \label{eq:var4}\\
    		& = \frac{\sum_{i = 0}^{N - 1} x_{i}^{2}}{N}  - \mu^{2}
    \label{eq:var}
\end{align}

\subsubsection*{Code}
The following listening \ref{lst:sum} shows the summing of the pixels. The pixels are summed for the mean and squared for the variance at the same time. Furthermore, the pixels are temporarily stored in an array so that they can be used again at a later time. \\
Because this is the initialization, the entire neighborhood (WIN\_SIZE) is read. During the iteration sequence only one pixel column (WIN\_LENGTH)) is read in. \\
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the sum, label=lst:sum]
loop_rdata:for(uint16_t i = 0; i < WIN_SIZE; i++) {
	inPixel = inData.read();
	pixel[i] = inPixel.data;

	sum_Pixel += pixel[i];				// sum of the pixels
	tmp_pow = pixel[i] * pixel[i];
	sum_Pixel2 += tmp_pow;				// sum of the pixels^2
}
\end{lstlisting}
\end{minipage}

In a function the sums of the pixels are passed and the mean and the variance are calculated. \\
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the mean and variance, label=lst:mean_var]
mean = (sum_Pixel / WIN_SIZE);
var = sum_Pixel2 / WIN_SIZE - (mean * mean);
\end{lstlisting}
\end{minipage}


\subsection{Division} \label{ch:hls:div}
This section explains how the division of the equation \ref{eq:wallis_filter} for the Wallis filter is implemented. It is known that divisions in the FPGA take a long time and also require a lot of resources. Therefore the division will be examined in detail to optimize the code for throughput. \\
First, I would like to comment on the accuracy of the division. Because
resources can already be saved here. As discussed in chapter \ref{ch:ap}, a lot
of resources can be saved with the accuracy and when \texttt{ap\_ufixed} is used.
Finally, the calculated Wallis pixel is rounded to an integer between 0 - 255.
This means that the intermediate results do not have to be too accurate. With
Matlab and the simulation of the C/C++ code in Viviado HLS, this hypothesis was
tested and the accuracy of the data size adjusted. The data types ap\_[u]int and
ap\_[u]fixed used instead of floating point. The size of the data types can be
found in table \ref{tab:datatypes}. Some of the data size do not match the
min/max value. The reason is that the results are rounded and an overflow may be
based on the next larger data size. For security reasons, the data types are
usually one bit larger. A table with a description of the variables can be found
in the appendix \ref{app:datatypes}.

\begin{table}[tb!]
    \centering
    \begin{tabularx}{\textwidth}{l l l l l l}
        \toprule
        Name & Type & Size & min Value & max Value & Dependence \\
        \midrule
        iPxl & ap\_uint & 8 & 0 & 255 & \\
        g\_Mean & ap\_uint & 8 & 0 & 255 &  \\
        g\_Var & ap\_uint & 14 & 0 & 16383 &  \\
        n\_Mean & ap\_uint & 8 & 0 & 255 &  \\
        n\_Var & ap\_uint & 14 & 0 & 16383 &  \\
        brightness & ap\_ufixed & 5,1 & 0 & 1 &  \\
        contrast & ap\_ufixed & 5,1 & 0 & 1 &  \\
        b\_gMean & ap\_uint & 8 & 0 & 255 &  brightness, g\_Mean\\
        ci\_gVar & ap\_uint & 14 & 0 & 16383 &  contrast, g\_Var\\
        tmp\_Num & ap\_int & 23 & -4177665 & 4177665 &  iPxl, n\_Mean, g\_Var \\
        num & ap\_int & 23 & -4177665 & 4177665 &  tmp\_Num, contrast \\
        c\_nVar & ap\_uint & 14 & 0 & 16383 &  n\_Var, contrast \\
        bi\_nMean & ap\_uint & 8 & 0 & 255 &  n\_Mean, brightness \\
        den\_Var & ap\_uint & 14 & 0 & 16383 &  n\_Var, ci\_gVar \\
        rec & ap\_ufixed & 18,1 & 1 & 1 &   \\
        den & ap\_ufixed & 18,1 & $\approx$0 & 1 &  rec, den\_Var \\
        div & ap\_int & 23 & -4177665 & 4177665 &  num, den \\
        w\_pixel & ap\_int & 23 & -4177665 & 4177665 &  div, b\_gMean, bi\_nMean \\
        \bottomrule
    \end{tabularx}
    \caption{Accuracy of data types in the Wallis filter division}
    \label{tab:datatypes}
\end{table}

Now let us take a closer look at the calculation of the division. The equation
of the Wallis filter results in the division of $\frac{x}{y}$. This means that
the dividend and the divisor change with each pixel. This could be programmed in
the FPGA with $\frac{x}{y}$. But as it is known, a multiplication in the FPGA is
faster than a division. Therefore we want to replace the $\frac{x}{y}$ division with a reciprocal version $\frac{1}{y}$, where afterwards the dividend is multiplied by the result of the reciprocal division $(\frac{1}{y}) \cdot x$. The latency of these two methods were measured in Vivado HLS and are shown in Table \ref{tab:c_div}. \\

\begin{table}[tb!]
    \centering
    \begin{tabular}{l c}
        \toprule
        Division & Latency [clocks]  \\
        \midrule
        $\frac{x}{y}$ & 28 
        \\
        $\frac{1}{y} \cdot x$ & 23 
        \\
        \bottomrule
    \end{tabular}
    \caption{Comparision of division methods}
    \label{tab:c_div}
\end{table}

\subsubsection*{Code}
The decision of the division was made on the reciprocal version, because it has a lower latency. In addition, the accuracy of the division was limited. Because finally the calculated pixel is rounded to an integer between 0-255 and the simulation has shown that it is not necessary to calculate infinite accurately. The code of the division and the data types used is below:

\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the division for the Wallis filter, label=lst:division]
ap_ufixed<18,1> rec = 1.0;
ap_uint<15> fp_Var;
ap_ufixed<18,1> fp_Den;
ap_int<23> fp_Num;
ap_int<23> fp_Div;

fp_Den = rec/fp_Var;
fp_Div = fp_Num * fp_Den;
\end{lstlisting}
\end{minipage}


\subsection{AXI4-Stream}
The calculation of the Wallis filter requires at least 21 pixels. Due to the initial AXI4-Stream data size (8 bits), 21 clock cycles have to be waited until the calculation can be started. Since only 1 pixel was received per clock. This also prevents the loops from unrolling, as not all data is available at the input (\ref{ch:directives}). \\
The advantage of Vivado HLS is that interfaces, for example, can be adapted relatively easily and quickly. The AXI4-Stream has therefore been enlarged to receive one column per clock. This means that the AXI4-Stream has been extended to a data width of 256 bits (\cite{axi_stream}). This also made it possible to add the directive \texttt{unroll} to the loops. Throughput has increased by a factor of 21.

\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the division for the Wallis filter, label=lst:division]
typedef ap_axiu<8,1,1,1> AXI_VALUE;			// <TDATA, TUSER, TID, TDEST>
typedef hls::stream<AXI_VALUE> AXI_STREAM;

/* Change to: */

typedef ap_axiu<256,1,1,1> AXI_VALUE;		// <TDATA, TUSER, TID, TDEST>
typedef hls::stream<AXI_VALUE> AXI_STREAM;
\end{lstlisting}
\end{minipage}

\subsection{Array Partition}
The pixels are sent to the Wallis IP core via AXI4-Stream. An AXI4-Stream can be imagined as a FIFO. When the data is read, it is no longer available at the input of the AXI4-Stream. This means the pixels have to be temporarily stored, because the pixels are used again with every iteration (\ref{ch:ip:concept}). \\
The pixels are temporarily stored in a block RAM (BRAM). But this brings another problem. With a BRAM only 1 pixel per clock can be read. 21 pixels must be processed per iteration. The latency would be at least 21 clock cycles if it were stored in a BRAM. \\
With the directive \texttt{array\_partition} (see chapter \ref{ch:directives})
an array can be divided into multiple smaller arrays. The array is divided into 21 smaller arrays. So it is possible to read 21 pixels per clock and there is no problem with the latency. \\
In the listening \ref{lst:array_partition} the array pixel is partitioned into 21 arrays with the directive \texttt{array\_partition}, so that 21 pixels per clock can be read. 
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=TextStyle, caption=Set directive array\_partition, label=lst:array_partition]
set_directive_array_partition -type cyclic -factor 21 -dim 1 "wallis" pixel
\end{lstlisting}
\end{minipage}



\section{Implementation (VHDL)} \label{ch:ip:imp_vhdl}
This chapter describes the Wallis filter with the calculation of the mean and the variance in the programming language VHDL. This makes it possible to check in chapter \ref{chapt:ver_bench} what are the advantages of the FPGA description in the C/C++ language with Vivado HLS. \\
Chapter \ref{ch:concept_vhdl} contains the concept of the VHDL code by using a block diagram. This is divided into the calculation of the mean and variance, as well as the Wallis algorithm. The following chapter describes the problems with programming the algorithm.

\subsection{Concept} \label{ch:concept_vhdl}
This chapter presents the concept of the mean and the variance, as well as the Wallis filter. They are shown as a block diagram and are briefly explained.

\subsubsection*{Mean \& Variance}
Block diagram \ref{fig:mean_var_vhdl} is based on the two equations of the mean \ref{eq:mean} and the varince \ref{eq:var}. \\
The pixel data is sent as 8 bit AXI4-Stream into the IP core. The data is
received from the block \texttt{dir\_shift\_reg} . This block is used for
initialization and iteration sequence, which is shown in figure 
\ref{fig:sequence}. All pixels are passed directly to the plus output and
through a FIFO with a delay of 441 pixels. This FIFO is used to subtract the
oldest pixels from the sum of the pixels, as shown in figure \ref{fig:sequence}.
Therefore, this path goes to the minus output. Figure \ref{fig:sim_shift_sum}
shows the simulation of the block \texttt{dir\_shift\_reg}. The delay of the
input data can be seen at the minus output. \\
In the block \texttt{sum\_diff} the two outputs of the block 
\texttt{dir\_shift\_reg} are subtracted from each other and the result would be
added in a sequence of 441 cycles. In the initialization sequence, the minus output is zero and the pixels are only added. This also means that a correct result is only obtained after 441 clock cycles and then still 21 clock cycles again if the IP core is in the iteration sequence. Figure \ref{fig:sim_shift_sum} shows the simulation of the block \texttt{sum\_diff}. The difference of the input data of the \texttt{dir\_shift\_reg} can be seen at the output.\\
Finally, the sum of the pixels is divided by $1/N$ where N is 441. For the variance, the square mean is subtracted. The mean and the variance are passed to the Wallis Filter.

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth, keepaspectratio}
        \input{images/image_processing/mean_var_vhdl.tikz}
    \end{adjustbox}
    \caption{Concept of the mean and variance implementation in VHDL}
    \label{fig:mean_var_vhdl}
\end{figure}

\begin{figure}[tb!]
    \centering
    \includegraphics[width=\textwidth]
    {images/image_processing/dir_shift_sum_diff.png}
    \caption{Simulation of the \texttt{dir\_shift\_reg} and the
    \texttt{sum\_diff} block with a \texttt{WIN\_SIZE} of 9}
    \label{fig:sim_shift_sum}
\end{figure}


\subsubsection*{Wallis Algorithm}
Block diagram \ref{fig:wallis_vhdl} is based on the equations of the Wallis algorithm \ref{eq:wallis_filter}.
The pixel to be calculated is connected to the IP core via AXI4-Stream. The constant parameters are connected to the \texttt{controller} and are sent from the computer via user register. \\
The division is solved with the \texttt{Divider Generator}. This is an IP core
by Xilinx that can be configuered to implement different algorithms for
divisions. Once the pixel is calculated, it is sent to the controller via AXI4-Stream.

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        \input{images/image_processing/wallis_vhdl.tikz}
    \end{adjustbox}
    \caption{Concept of the Wallis filter implementation in VHDL}
    \label{fig:wallis_vhdl}
\end{figure}

\subsection{Hurdles} \label{ch:ip:hurdles_vhdl}
This chapter is about the hurdles in programming with VHDL and the implementation of the mean and the variance, as well as the Wallis algorithm.
The division and the storage of fractional numbers are discussed.

\subsubsection*{Mean \& Variance}
A division exists in the calculation of the mean and the variance. As already mentioned in chapter \ref{ch:hls:div}, a division in an FPGA is a complex task.
This division is relatively easy to solve. As can be seen from the equation of
the two calculations (\ref{eq:mean} \& \ref{eq:var}), the divisor is constant.
This gives the possibility to calculate $1/N$ in advance and to store the
obtained value as a constant in the FPGA. This results in a multiplication with
two integers in the FPGA that are interpreted as fractionals and can be
calculated in one clock cycle. \\
Calculated $1/441$ results in $\approx 0.00226757$. This number is converted to
binary and results in $\approx 0.00000000100101001001101$. The following number
is stored as a constant $100101001001101$. Note that 8 decimal digits have been
removed. This must be observed in the following calculations, because the
decimal place can change with each calculation. Figure \ref{fig:data_mean_var}
lists the data widths for the calculation of the mean and the variance. The
square brackets contain the entire data width. If there are two numbers in the
square brackets, the first is the entire data width and the second is the
integer width. The sign is in front of the brackets: u for unsigned and s for
signed.

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth, keepaspectratio}
        \input{images/image_processing/datawidth_mean_var.tikz}
    \end{adjustbox}
    \caption{Data width of mean and variance calculation}
    \label{fig:data_mean_var}
\end{figure}

\subsubsection*{Wallis Algorithm}
The Wallis algorithm also contains a division. In this case, however, it is not
possible to simplify them
because the numerator and denumerator change with each pixel. \\
Xilinx has an IP core which solves divisions. It is called \texttt{Divider Generator} \cite{divider}. The \texttt{Divider Generator} contains three different implementations of divisions (LUTMult, Radix-2, High Radix). These three divisions are distinguished by resource consumption, latency and throughput. The numerator and denumerator can be passed to the \texttt{Divider Generator} via AXI4-Stream. The result is again sent via AXI4-Stream. \\
The decision was made to implement the High-Radix. Due to the size of the dividend the LUTMult was omitted and because of the latency the implementation of the Radix-2. The divider should accepted a new division after at most 21 clock cycles, because this is the time of the iteration sequence. This is fulfilled by the implementation of the High-Radix. The latency and throughput of the calculation can be influenced during implementation \cite{divider}.
