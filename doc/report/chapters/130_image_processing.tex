% ==============================================================================
%
%                             Image Processing
%
% ==============================================================================
\chapter{Image Processing}  \label{chapt:image_processing}
The Wallis Fitler is implemented as an image processing algorithm. First follows the concept of the algorithm and following the implementation of the filter in the Vivado HLS using C code. The simplifications and optimizations of the algorithm with Vivado HLS are also explained in this chapter. In the chapter \ref{ch:ip:imp_vhdl} is the implementation using VHDL. Here again a concept is shown how the code is implemented.

\section{Concept} \label{ch:ip:concept}
The figure \ref{fig:concept} shows the concept of the C/C++ code programmed in the Vivado HLS. First, the mean and the variance must be calculated so that the Wallis filter can be applied afterwards with the parameters and the pixel $I(x,y)$ that is to be calculated. The calculated pixel is $I'(x,y)$ \\
The sequence of the code is shown in the figure \ref{fig:sequence}. This consists of an initialization and a iteration. During the initialization, the complete neighborhood is read in and the central pixel of the neighborhood is calculated. To calculate the next pixel, only one new column is read in. This step is the so called iteration.\\
The code is row based. This means that each new row of an image have the initialization procedure.

\todo[inline]{tikz mit dem Konzept und der Sequenz (Init and Iter)}
\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        \input{images/image_processing/concept.tikz}
    \end{adjustbox}
    \caption{Concept of the Wallis filter implementation}
    \label{fig:concept}
\end{figure}

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        %\input{images/image_processing/concept.tikz}
    \end{adjustbox}
    \caption{Sequence of the code with initialization and iteration}
    \label{fig:sequence}
\end{figure}


\section{Implementation (HLS) \& Optimization}
The following three chapters explain the implementation of the Wallis filter in C code. First, the simplification of the mean and the variance. Then the Fixed Point calculation of the Wallis equation and in the third chapter the optimizations using pragmas in Viviado HLS.

\subsection{Mean \& Variance}
In this section we will go in detail on the mean and the variance, so that it can be calculated more efficiently with the FPGA. The problem is that the equation we know for the variance (\ref{eq:var1}) must first calculate the mean (\ref{eq:mean}). \\
No adjustment is necessary for the equation for the mean. This can be used as usual. The following equation	is used to calculate the mean:
\begin{equation}
    \mu = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}
    \label{eq:mean}
\end{equation} 

The equation we know for variance \ref{eq:var1} is adjusted for the calculation. As can be seen, the mean must first be calculated so that the calculation of the variance can be started at all. The goal is to start the calculation of the mean and the variance at the same time. So that this can be implemented more effectively in the FPGA. \\
The equation \ref{eq:var1} is multiplied and is given the equation \ref{eq:var2}. If this is still represented a little differently one gets the equation \ref{eq:var3}. In this case it is to be recognized that in the second term the mean results $\mu = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}$. In the third term, the sum $\sum_{i = 0}^{N - 1} 1$ is $N$. \\
This adjustment leads to the equation \ref{eq:var} implemented in the FPGA. The implementation of the equation is shown in the concept in the figure \ref{fig:concept} in the mean and variance block.
\begin{align}
    \sigma^{2} & = \frac{1}{N} \sum_{i = 0}^{N - 1} (x_{i} - u)^{2} \label{eq:var1}\\ 
    		& = \frac{1}{N} \sum_{i = 0}^{N - 1} (x_{i}^{2} - 2 \mu x_{i} + \mu^{2})  \label{eq:var2}\\
    		& = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}^{2} - 2\mu \frac{\sum_{i = 0}^{N - 1} x_{i}}{N} + \frac{1}{N} \mu^{2} \sum_{i = 0}^{N - 1} 1 \label{eq:var3}\\
    		& = \frac{\sum_{i = 0}^{N - 1} x_{i}^{2}}{N}  - 2\mu^{2} + \mu^{2} \label{eq:var4}\\
    		& = \frac{\sum_{i = 0}^{N - 1} x_{i}^{2}}{N}  - \mu^{2}
    \label{eq:var}
\end{align}

\subsubsection*{Code}
The following listening \ref{lst:sum} shows the summing of the pixels. The pixels are summed for the mean and squared for the variance at the same time. Furthermore, the pixels are temporarily stored in an array so that they can be used again at a later time. \\
Cause this is the initialization, the entire neighborhood (WIN\_SIZE) is read in. During the iteration sequence only one pixel column (sqrt(WIN\_SIZE)) is read in. \\
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the sum, label=lst:sum]
loop_rdata:for(uint16_t i = 0; i < WIN_SIZE; i++) {
	inPixel = inData.read();
	pixel[i] = inPixel.data;

	sum_Pixel += pixel[i];				// sum of the pixels
	tmp_pow = pixel[i] * pixel[i];
	sum_Pixel2 += tmp_pow;				// sum of the pixels^2
}
\end{lstlisting}
\end{minipage}

In a function the sums of the pixels are passed and the mean and the variance are calculated. \\
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the mean and variance, label=lst:mean_var]
mean = (sum_Pixel / WIN_SIZE);
var = sum_Pixel2 / WIN_SIZE - (mean * mean);
\end{lstlisting}
\end{minipage}


\subsection{Division} \label{ch:hls:div}
This section explains how the division of the equation \ref{eq:wallis_filter} for the Wallis filter is implemented. It is known that divisions in the FPGA take a long time and also require a lot of resources. Therefore the division will be examined in detail to optimize the code for throughput. \\
First, I would like to comment on the accuracy of the division. Because resources can already be saved here. As discussed in chapter \ref{ch:ap}, a lot of resources can be saved with the accuracy and when apufixed is used.
Finally, the calculated Wallis pixel is rounded to an integer between 0 - 255. This means that the intermediate results do not have to be infinitely accurate. With Matlab and the simulation of the C/C++ code in Viviado HLS, this hypothesis was tested and the accuracy of the data types adjusted. The data types ap\_[u]int and ap\_[u]fixed used instead of floating point. The size of the data types can be found in table \ref{tab:datatypes}. 

\todo[inline]{Tabelle fuellen}
\begin{table}[tb!]
    \centering
    \begin{tabular}{l l l l l l}
        \toprule
        Name & Type & Size & min Value & max Value & Comment \\
        \midrule
        &  &  &  &  & 
        \\

        \bottomrule
    \end{tabular}
    \caption{Accuracy of data types in the Wallis Filter division}
    \label{tab:datatypes}
\end{table}

Now let us take a closer look at the calculation of the division. The equation of the Wallis filter results in the division of $\frac{x}{y}$. This means that the dividend and the divisor change with each pixel. This could be programmed in the FPGA with $\frac{x}{y}$. But as it is known, a multiplication in the FPGA is faster than a division. Therefore we want to check the $\frac{x}{y}$ division with a reciprocal version $\frac{1}{y}$, where afterwards the dividend is multiplied by the result of the reciprocal division $(\frac{1}{y}) \cdot x$. The latency of these two divisions is shown in Table \ref{tab:c_div}. \\

\begin{table}[tb!]
    \centering
    \begin{tabular}{l c}
        \toprule
        Division & Latency [clocks]  \\
        \midrule
        $\frac{x}{y}$ & 28 
        \\
        $\frac{1}{y} \cdot x$ & 23 
        \\
        \bottomrule
    \end{tabular}
    \caption{Comparision of division methods}
    \label{tab:c_div}
\end{table}

\subsubsection*{Code}
The decision of the division was made on the reciprocal version, because it has a lower latency. In addition, the accuracy of the division was limited. Because finally the calculated pixel is rounded to an integer between 0-255 and the simulation has shown that it is not necessary to calculate infinite accurately. The code of the division and the data types used is below:

\todo[inline]{groesse der Datentypen ueberpruefen!!!}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the division for the Wallis filter, label=lst:division]
ap_ufixed<18,1> rec = 1.0;
ap_uint<15> fp_Var;
ap_ufixed<18,1> fp_Den;
ap_int<23> fp_Num;
ap_int<31> fp_Div;

fp_Den = rec/fp_Var;
fp_Div = fp_Num * fp_Den;
\end{lstlisting}
\end{minipage}


\subsection{AXI4-Stream}
The calculation of the Wallis filter requires at least 21 pixels. Due of the limited AXI4-Stream (8 bits) as input stream, 21 clock cycles have to be waited until the calculation can be started. Since only 1 pixel was received per clock. This also prevents the for loops from unrolling, as not all data is available at the input (\ref{ch:directives}). \\
The advantage of Vivado HLS is that interfaces, for example, can be adapted relatively easily and quickly. The AXI4-Stream has therefore been enlarged to receive one column per clock. This means that the AXI4-Stream has been extended to a data width of 256 bits (\cite{axi_stream}). This also made it possible to add the directive \texttt{unroll} to the for loops. Throughput has increased by a factor of 21.
\todo[inline]{Fakotr 21 korrekt (throughput von 8bits auf 256bits)}

\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the division for the Wallis filter, label=lst:division]
typedef ap_axiu<8,1,1,1> AXI_VALUE;			// <TDATA, TUSER, TID, TDEST>
typedef hls::stream<AXI_VALUE> AXI_STREAM;

/* Change to: */

typedef ap_axiu<256,1,1,1> AXI_VALUE;		// <TDATA, TUSER, TID, TDEST>
typedef hls::stream<AXI_VALUE> AXI_STREAM;
\end{lstlisting}
\end{minipage}

\subsection{Array Partition}
The pixels are sent to the Wallis IP core via AXI4-Stream. An AXI4-Stream can be imagined as a FIFO. When the data is read, it is no longer available at the input of the AXI4-Stream. This means the pixels have to be temporarily stored, because the pixels are used again with every iteration (\ref{ch:ip:concept}). \\
The pixels are temporarily stored in a block RAM (BRAM). But this brings another problem. With a BRAM only 1 pixel per clock can be read. 21 pixels must be processed per iteration. The latency would be at least 21 clock cycles if it were stored in a BRAM. \\
With the directive \texttt{array\_partition} (\ref{ch:directives}) an array can be divided into multiple smaller arrays. The array is divided into 21 smaller arrays. So it is possible to read 21 pixels per clock and there is no problem with the latency. \\
In the listening \ref{lst:array_partition} the array pixel is partitioned into 21 arrays with the directive \texttt{array\_partition}, so that 21 pixels per clock can be read. 

\begin{minipage}{\textwidth}
\begin{lstlisting}[style=TextStyle, caption=Set directive array\_partition, label=lst:array_partition]
set_directive_array_partition -type cyclic -factor 21 -dim 1 "wallis" pixel
\end{lstlisting}
\end{minipage}



\section{Implementation (VHDL)} \label{ch:ip:imp_vhdl}
This chapter describes the Wallis filter with the calculation of the mean and the variance in the programming language VHDL. This makes it possible to check in chapter \ref{chapt:ver_bench} what are the advantages of the FPGA description in the C/C++ language with Vivado HLS. \\
Chapter \ref{ch:concept_vhdl} contains the concept of the VHDL code by using a block diagram. This is divided into the calculation of the mean and variance, as well as the Wallis algorithm. The following chapter describes the problems with programming the algorithm.

\subsection{Concept} \label{ch:concept_vhdl}
This chapter presents the concept of the mean and the variance, as well as the Wallis filter. They are shown as a block diagram and are briefly explained.

\subsubsection*{Mean \& Variance}
Block diagram \ref{fig:mean_var_vhdl} is based on the two equations of the mean \ref{eq:mean} and the varince \ref{eq:var}. \\
The pixel data is sent as 8 bit AXI4-Stream into the IP core. The data is received from the \texttt{dir\_shift\_reg} block. This block is used for initialization and iteration sequence, which is shown in Figure \ref{fig:sequence}. All pixels are passed directly to the plus output and through a FIFO of a space of 441 pixels. This FIFO is used to subtract the oldest pixels from the sum of the pixels, as shown in figure \ref{fig:sequence}. Therefore, this path goes to the minus output. The number 441 comes from the neighborhood which is $21 \cdot 21$. \\
In the block \texttt{sum\_diff} the two outputs of the block \texttt{dir\_shift\_reg} are subtracted from each other and the result would be added in a sequence of 441 cycles. In the initialization sequence, the minus output is zero and the pixels are only added. This also means that a correct result s only obtained after 441 clock cycles and then still 21 clock cycles again if the IP core is in the iteration sequence. \\
Finally, the sum of the pixels is divided by $1/N$ where N is 441. For the variance, the square mean is subtracted. The mean and the variance are passed to the Wallis Filter.

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        \input{images/image_processing/mean_var_vhdl.tikz}
    \end{adjustbox}
    \caption{Concept of the mean and variance implementation in VHDL}
    \label{fig:mean_var_vhdl}
\end{figure}

\subsubsection*{Wallis Algorithm}
Block diagram \ref{fig:wallis_vhdl} is based on the equations of the Wallis algorithm \ref{eq:wallis_filter}. \\
The pixel to be calculated is connected to the IP core via AXI4-Stream. The remaining parameters are connected to the AXI4-Lite \todo{AXI4-Lite korrekt?} interface. \\
The division is solved with the \texttt{Divider Generator}. This is an IP core of Xilinx that can be divided. Once the pixel is calculated, it is sent to the controller via AXI4-Stream.

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        \input{images/image_processing/wallis_vhdl.tikz}
    \end{adjustbox}
    \caption{Concept of the Wallis filter implementation in VHDL}
    \label{fig:wallis_vhdl}
\end{figure}

\subsection{Hurdles} \label{ch:ip:hurdles_vhdl}
This chapter is about the hurdles in programming with VHDL and the two implementation of the mean and the variance, as well as the Wallis algorithm. The divisions and the storage of numbers <1 play a role here.

\subsubsection*{Mean \& Variance}
A division exists in the calculation of the mean and the variance. As already mentioned in chapter \ref{ch:hls:div}, a division in an FPGA is a complex task. \\
This division is relatively easy to solve. As can be seen from the equation of the two calculations (\ref{eq:mean} \& \ref{eq:var}), the divisor is constant. This gives the possibility to calculate $1/N$ in advance and to store the obtained value as a constant in the FPGA. This results in a multiplication with two integers in the FPGA. \\
Calculated $1/441$ results in $\approx 0.00226757$. This number is converted to binary and results in $\approx 0.0000000000100100101001001101$. The following number is stored as a constant $100101001001001101$. Note that 8 decimal digits have been removed. This must be observed with the following calculations, because the decimal place can change with each calculation! \\
Since the division results in a multiplication of two integers, this can be processed in one clock cycle.


\subsubsection*{Wallis Algorithm}
In the Wallis algorithm it also has a division. In this case, however, it is not possible to simplify them because the numerator and denumerator change with each pixel. \\
Xilinx has an IP core which solves divisions. It is called \texttt{Divider Generator} \cite{divider}. The \texttt{Divider Generator} contains three different implementations of divisions (LUTMult, Radix-2, High Radix). These three divisions are distinguished by resource consumption, latency and throughput. The numerator and denumerator can be passed to the \texttt{Divider Generator} via AXI4-Stream. The result is again sent via AXI4-Stream. \\
The decision was made to implement the High-Radix. Due to the size of the dividend the LUTMult was omitted and because of the latency the implementation of the Radix-2. The latency of the divider should not exceed 21 clock cycles, because this is in the time of the iteration sequence and there is no delay in the calculation of the pixels. This could be fulfilled by the implementation of the High-Radix. The latency of the calculation can be influenced during implementation \cite{divider}.
