% ==============================================================================
%
%                             Image Processing
%
% ==============================================================================
\chapter{Image Processing}  \label{chapt:image_processing}
The Wallis Fitler is implemented as an image processing algorithm. First follows the concept of the algorithm and following the implementation of the filter in the Vivado HLS using C code. The simplifications and optimizations of the algorithm with Vivado HLS are also explained in this chapter. In the chapter \ref{ch:ip:imp_vhdl} is the implementation using VHDL. Here again a concept is shown how the code is implemented.

\section{Concept}
The figure \ref{fig:concept} shows the concept of the C code programmed in the Vivado HLS. First, the mean and the variance must be calculated so that the Wallis filter can be applied afterwards with the parameters. \\
The sequence of the code is shown in the figure \ref{fig:sequence}. This consists of an initialization and a iteration. During the initialization, the complete neighborhood is read in and the central pixel of the neighborhood is calculated. To calculate the next pixel, only one new column is read in. This step is the so called iteration.\\
The code is row based. This means that each new row of an image have the initialization procedure.

\todo[inline]{tikz mit dem Konzept und der Sequenz (Init and Iter)}
\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        %\input{images/theory/concept.tikz}
    \end{adjustbox}
    \caption{Concept of the Wallis filter implementation}
    \label{fig:concept}
\end{figure}

\begin{figure}[tb!]
    \centering
    \begin{adjustbox}{max width=\textwidth}
        %\input{images/theory/concept.tikz}
    \end{adjustbox}
    \caption{Sequence of the code with initialization and iteration}
    \label{fig:sequence}
\end{figure}


\section{Implementation (HLS) \& Optimization}
The following three chapters explain the implementation of the Wallis filter in C code. First, the simplification of the mean and the variance. Then the Fixed Point calculation of the Wallis equation and in the third chapter the optimizations using pragmas in Viviado HLS.

\subsection{Mean \& Variance}
In this section we will go in detail on the mean and the variance, so that it can be calculated more efficiently with the FPGA. The problem is that the equation we know for the variance (\ref{eq:var1}) must first calculate the mean (\ref{eq:mean}). \\
No adjustment is necessary for the equation for the mean. This can be used as usual. The following equation	is used to calculate the mean:
\begin{equation}
    \mu = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}
    \label{eq:mean}
\end{equation} 

The equation we know for variance \ref{eq:var1} is adjusted for the calculation. As can be seen, the mean must first be calculated so that the calculation of the variance can be started at all. The goal is to start the calculation of the mean and the variance at the same time. So that this can be implemented more effectively in the FPGA. \\
The equation \ref{eq:var1} is multiplied and is given the equation \ref{eq:var2}. If this is still represented a little differently one gets the equation \ref{eq:var3}. In this case it is to be recognized that in the second term the mean results $\mu = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}$. In the third term, the sum $\sum_{i = 0}^{N - 1} 1$ is $N$. \\
This adjustment leads to the equation \ref{eq:var} implemented in the FPGA. The implementation of the equation is shown in the concept in the figure \ref{fig:concept} in the mean and variance block.
\begin{align}
    \sigma^{2} & = \frac{1}{N} \sum_{i = 0}^{N - 1} (x_{i} - u)^{2} \label{eq:var1}\\ 
    		& = \frac{1}{N} \sum_{i = 0}^{N - 1} (x_{i}^{2} - 2 \mu x_{i} + \mu^{2})  \label{eq:var2}\\
    		& = \frac{1}{N} \sum_{i = 0}^{N - 1} x_{i}^{2} - 2\mu \frac{\sum_{i = 0}^{N - 1} x_{i}}{N} + \frac{1}{N} \mu^{2} \sum_{i = 0}^{N - 1} 1 \label{eq:var3}\\
    		& = \frac{\sum_{i = 0}^{N - 1} x_{i}^{2}}{N}  - 2\mu^{2} + \mu^{2} \label{eq:var4}\\
    		& = \frac{\sum_{i = 0}^{N - 1} x_{i}^{2}}{N}  - \mu^{2}
    \label{eq:var}
\end{align}

\subsubsection*{Code}
The following listening \ref{lst:sum} shows the summing of the pixels. The pixels are summed for the mean and squared for the variance at the same time. Furthermore, the pixels are temporarily stored in an array so that they can be used again at a later time. \\
Cause this is the initialization, the entire neighborhood (WIN\_SIZE) is read in. During the iteration sequence only one pixel column (sqrt(WIN\_SIZE)) is read in. \\
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the sum, label=lst:sum]
loop_rdata:for(uint16_t i = 0; i < WIN_SIZE; i++) {
	inPixel = inData.read();
	pixel[i] = inPixel.data;

	sum_Pixel += pixel[i];				// sum of the pixels
	tmp_pow = pixel[i] * pixel[i];
	sum_Pixel2 += tmp_pow;				// sum of the pixels^2
}
\end{lstlisting}
\end{minipage}

In a function the sums of the pixels are passed and the mean and the variance are calculated. \\
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the mean and variance, label=lst:mean_var]
mean = (sum_Pixel / WIN_SIZE);
var = sum_Pixel2 / WIN_SIZE - (mean * mean);
\end{lstlisting}
\end{minipage}


\subsection{Division}
This section explains how the division of the equation \ref{eq:wallis_filter} for the Wallis filter is implemented. It is known that divisions in the FPGA take a long time and also require a lot of resources. Therefore the division will be examined in detail to optimize the code for throughput. \\
First, I would like to comment on the accuracy of the division. Because resources can already be saved here. As discussed in chapter \ref{ch:ap}, a lot of resources can be saved with the accuracy and when apufixed is used.
Finally, the calculated Wallis pixel is rounded to an integer between 0 - 255. This means that the intermediate results do not have to be infinitely accurate. With Matlab and the simulation of the C/C++ code in Viviado HLS, this hypothesis was tested and the accuracy of the data types adjusted. The data types ap\_[u]int and ap\_[u]fixed used instead of floating point. The size of the data types can be found in table \ref{tab:datatypes}. 

\todo[inline]{Tabelle fuellen}
\begin{table}[tb!]
    \centering
    \begin{tabular}{l l l l l l}
        \toprule
        Name & Type & Size & min Value & max Value & Comment \\
        \midrule
        &  &  &  &  & 
        \\

        \bottomrule
    \end{tabular}
    \caption{Accuracy of data types in the Wallis Filter division}
    \label{tab:datatypes}
\end{table}

Now let us take a closer look at the calculation of the division. The equation of the Wallis filter results in the division of $\frac{x}{y}$. This means that the dividend and the divisor change with each pixel. This could be programmed in the FPGA with $\frac{x}{y}$. But as it is known, a multiplication in the FPGA is faster than a division. Therefore we want to check the $\frac{x}{y}$ division with a reciprocal version $\frac{1}{y}$, where afterwards the dividend is multiplied by the result of the reciprocal division $(\frac{1}{y}) \cdot x$. The latency of these two divisions is shown in Table \ref{tab:c_div}. \\

\begin{table}[tb!]
    \centering
    \begin{tabular}{l c}
        \toprule
        Division & Latency [clocks]  \\
        \midrule
        $\frac{x}{y}$ & 28 
        \\
        $\frac{1}{y} \cdot x$ & 23 
        \\
        \bottomrule
    \end{tabular}
    \caption{Comparision of division methods}
    \label{tab:c_div}
\end{table}

\subsubsection*{Code}
The decision of the division was made on the reciprocal version, because it has a lower latency. In addition, the accuracy of the division was limited. Because finally the calculated pixel is rounded to an integer between 0-255 and the simulation has shown that it is not necessary to calculate infinite accurately. The code of the division and the data types used is below:

\todo[inline]{groesse der Datentypen ueberpruefen!!!}
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the division for the Wallis filter, label=lst:division]
ap_ufixed<18,1> rec = 1.0;
ap_uint<15> fp_Var;
ap_ufixed<18,1> fp_Den;
ap_int<23> fp_Num;
ap_int<31> fp_Div;

fp_Den = rec/fp_Var;
fp_Div = fp_Num * fp_Den;
\end{lstlisting}
\end{minipage}


\subsection{AXI4-Stream}
The calculation of the Wallis filter requires at least 21 pixels. Due of the limited AXI4-Stream (8 bits) as input stream, 21 clock cycles have to be waited until the calculation can be started. Since only 1 pixel was received per clock. This also prevents the for loops from unrolling, as not all data is available at the input (\ref{ch:directives}). \\
The advantage of Vivado HLS is that interfaces, for example, can be adapted relatively easily and quickly. The AXI4-Stream has therefore been enlarged to receive one column per clock. This means that the AXI4-Stream has been extended to a data width of 256 bits. This also made it possible to add the directive \texttt{unroll} to the for loops. The latency of both versions is shown in Table \ref{tab:axi4}.
\todo[inline]{latency korrekt???}
\todo[inline]{latenz in tabelle enfuegen}

\begin{minipage}{\textwidth}
\begin{lstlisting}[style=CStyle, caption=Calculation of the division for the Wallis filter, label=lst:division]
typedef ap_axiu<8,1,1,1> AXI_VALUE;			// <TDATA, TUSER, TID, TDEST>
typedef hls::stream<AXI_VALUE> AXI_STREAM;

/* Change to: */

typedef ap_axiu<256,1,1,1> AXI_VALUE;		// <TDATA, TUSER, TID, TDEST>
typedef hls::stream<AXI_VALUE> AXI_STREAM;
\end{lstlisting}
\end{minipage}

\begin{table}[tb!]
    \centering
    \begin{tabular}{l c}
        \toprule
        AXI4-Stream & Latency [clocks]  \\
        \midrule
        8 bits & 
        \\
        256 bits &  
        \\
        \bottomrule
    \end{tabular}
    \caption{Comparision of AXI4-Stream data width}
    \label{tab:axi4}
\end{table}

\subsection{Array Partition}





% \subsection{Throughput Optimization} \label{ch:ip:throughput}
% If the FPGA is programmed using C/C++ language, then the C/C++ code is synthesized by Viviado HLS to VHDL. The C/C++ language is designed for sequential programming while on the other hand VHDL is designed for hardware description. This brings up two problems that have to be considered when programming in C/C++. First, the hiearchy of the C/C++ code should be as flat as possible. This means to be aware of how for-loops and if-statements are used. On the other hand, directives can be added to the C/C++ code. These directives instruct the tool how to synthesise the code.\\
% The directives and how to handle for-loops are explained in this chapter. The if-statements are explained in chapter \ref{ch:data:if}. \\

% \textbf{Directives:} If the FPGA is programmed using C/C++ language, there is no way to get around the directives. Directives are instructions to the compiler on how it should synthesize and optimize the code. Latency, throughput or area can be optimized \cite{pragma}. The Wallis Code has been optimized for throughput.
% Below are some directives used in the code to achieve optimal throughput.


% \subsubsection*{Interface}
% Each IP core has interfaces to receive or send data or control signals. The interface directive specifies the ports as they should be implemented during synthesis. \\
% The IP core can be controlled by the control signals. This means the IP core can be started or stopped. The IP core also has output control signals to indicate, for example, that it is ready for new data. \\
% For each IP core, Vivado's AXI4 interfaces can also be implemented to send data to the core. \\
% Among other things, block rams or fifos can also be connected directly to the IP core. \\
% \\

% In the Wallis filter, the pixels are transmitted to the IP core via AXI4-Stream. In the first implementation, the stream had a throughput of 8 bits per clock. In a further step to increase throughput, the AXI4-Stream has been extended to 256 bits. This has the advantage that 21 pixels per clock could be sent to the IP core. \\
% The parameters for the Wallis filter are sent to the IP core via AXI4-Lite. \\
% The used directives are listed in the listening below.

% \begin{minipage}{\textwidth}
% \begin{lstlisting}[style=TextStyle, label=lst:interface]
% set_directive_interface -mode axis -register -register_mode reverse "wallis" inData
% set_directive_interface -mode axis -register -register_mode forward "wallis" outData
% set_directive_interface -mode s_axilite -bundle ctrl "wallis" g_Mean
% set_directive_interface -mode s_axilite -bundle ctrl "wallis" g_Var
% set_directive_interface -mode s_axilite -bundle ctrl "wallis" contrast
% set_directive_interface -mode s_axilite -bundle ctrl "wallis" brightness

% \end{lstlisting}
% \end{minipage}



\section{Implementation (VHDL)} \label{ch:ip:imp_vhdl}

\subsection{Concept}